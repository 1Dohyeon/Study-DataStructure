O(logN) 시간보다 빠른 연산을 하기 위해서, 키와 1차원 배열의 인덱스 관계를 이용한다. Key가 22라면 1차원 배열의 22번째 인덱스에 value를 저장하는 것이다.

위 개념을 이용하는 자료구조가 바로 해시이다. 하지만 위처럼 key를 바로 인덱스로 매핑시키는 것이 아니라 해싱(Hashing)을 key값을 변환한다. Hashing이란 간단한 함수를 통해서 키를 변환 후 그 값을 인덱스로 하는 배열의 위치에 항목을 저장하는 것이다.

![[해싱 예시 이미지.png]]

키를 변환하는 함수를 해시 함수라고 하고, 해시값(Hash Value) 가 해시 함수가 계산을 하여 반환한 값이다. 이 값을 인덱스로 하는 배열이 바로 해시테이블(Hash Table) 이다.

하지만 만약에 서로 다른 키들이 같은 해시값을 갖게 되면 어떻게 될까? 바로 충돌(Collision) 이 발생한다. 해시함수들은 키들을 균등하게 해시테이블의 인덱스로 변환하여 충돌을 줄여야한다. 5.1과 5.2에서는 충돌된 키를 처리하는 과정을 설명한다.
### 5.1 Open Addressing

Open Addressing 은 개방주소방식이라고 하며 해시테이블 전체를 열린 공간으로 가정하고 충돌된 키를 일정한 방식에 따라서 찾아낸 빈 공간에 저장한다. 

**5.1.1 Linear Probing**

해시 함수 `h(key) = key % table.length` 의 형태를 갖고 있다고 가정하자. key 값을 해시 테이블의 길이로 나눈 나머지를 해시값으로 하는 것이다. 앞으로 첫 해시 결과는 이 방법을 이용한다.

Linear Probing(선형조사) 방식에서 충돌이 일어나게 된다면 바론 다음칸에 값을 집어넣는다. 또 그 자리에 이미 다른 값이 있다면 계속 1칸씩 이동하며 빈자리를 찾는다.

![[선형조사 예시 이미지.png]]

즉, 충돌시에 충돌이 일어난 위치부터 순차적으로 검색하여 빈 공간에 키를 저장하므로 `( h(key) + j ) % M` 형태를 가짐을 알 수 있다.

선형조사의 문제점은 바로 1차 군집화이다. 충돌된 키들은 순차적으로 찾은 빈공간에 저장하므로 동일 해시값을 갖는 키들은 한곳에 뭉치게 된다.

**5.1.2 Quad Probing**

Quad Probing(이차조사) 는 한칸씩 움직이는 것이 아닌 제곱칸씩 움직인다.(1칸, 4칸, 9칸 ...) 따라서 `( h(key) + j^2 ) % M` 형태를 가짐을 알 수 있다.

이와 같은 방식도 **2차 군집화(Secondary Clustering)** 라는 문제점이 발생한다. 서로 같은 해시값을 갖는 다른 키들이 똑같은 점프 시퀀스(Jump Sequence) 를 따라 빈 공간을 찾고 저장하므로 발생하는 다른 형태의 군집화를 뜻한다.

**5.1.3 Random Probing**

`( h(key) + rand() ) % M` 와 같이 Random Probing(랜덤 조사) 는 랜덤한 값으로 이동시켜 빈 공간을 찾아서 충돌을 처리하는 방법이다. 이 방법도 똑같은 점프 시퀀스에 따라 빈 공간을 찾아 키를 저장하므로, **3차 군집화**가 발생한다.

랜덤인데 어떻게 똑같은 점프 시퀀스가 나타나는지 궁금할 수도 있다. 첫 충돌이 있었던 키가 랜덤 값으로 3, 1, 4 만큼 이동하였다고 가정해보자. 다음 키도 충돌이 있다면 똑같이 3, 1, 4 만큼 이동하고 또 충돌이 있을 경우 다시 랜덤 크기만큼 점프를 한다. 

**5.1.4 Double Hashing**

Double Hashing(이중 해싱) 은 말 그대로 두번 해싱을 하는 것이다. 충돌이 일어나면 점프할 다음 위치를 정하기 위해 제 2의 해시함수 `d(key)` 를 사용한다. `( h(key) + j*d(key) ) % M` 형태를 가지며 처음 충돌이 일어나면 `key` 값을 한번 더 해싱한 값을 더한 것을 `M` 으로 나누면 되고, 또 충돌이 일어난다면 `d` 해싱에 2를 곱하고 위 과정을 반복하면 된다.

[전체 코드](https://github.com/1Dohyeon/Study-DataStructure/tree/master/05_Hash_with_java/D1_OpenAddressing)

### 5.2 Closed Addressing : Chaining

Closed Addressing 은 폐쇄주소방식이라고 하며 충돌한다면 빈 곳을 찾는게 아니라 충돌한 키들을 한 위치에 모아서 저장한다. 대표적인 방법으로는 chaining(체이닝)이 있다.

충돌이 일어나면 테이블의 각 인덱스 안에 [1.2 Singly Linked List](https://github.com/1Dohyeon/Study-DataStructure/blob/master/01_Lists_with_py/02_SinglyLinkedList.py) 에서 언급한 연결리스트를 추가하는 것이다. 

![[체이닝 예시 이미지.png]]

위와 같이 충돌이 일어난다면 저장되어 있는 연결리스트의 head 부분으로 새로운 노드가 삽입된다.

[전체 코드](https://github.com/1Dohyeon/Study-DataStructure/blob/master/05_Hash_with_java/D2_ClosedAddressing/Chaining.java)
