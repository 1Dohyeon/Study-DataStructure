그래프란 집합으로 설명하자면 정점 집합 `V`와 정점을 연결하는 간선 집합 `E`로 구성된 집합 `G` 이다.

지하철 노선도를 생각하면 쉽게 이해할 수 있다. 역들이 각 정점이고 역 사이를 연결하는 것이 바로 간선이다.

![[지하철 노선도 그래프 예시.png]]

### 7.1 DFS

**7.1.1 개념**

DFS란 Depth-First Search 의 약자이다. 말 그대로 깊이를 우선적으로 탐색한다. 즉 더 이동할 수 있을 정도로 다 이동하고 이동할 곳이 없다면 다른 간선에서 이 과정을 반복한다.(아래 그림 참고)

![[dfs 예제.png]]

**7.1.2 pseudocode**
``` c
DFS(G) 
{ 
	for each v ∈ V 
		visited[v] ← NO; 
	for each v ∈ V 
		if (visited[v] = NO) then aDFS(v); 
} 
aDFS (v) 
{ 
	visited[v] ← YES; 
	for each x ∈ L(v) ▷ L(v) : 정점 v의 인접 리스트 
		if (visited[x] = NO) then aDFS(x); 
}
```
**DFS(G) 함수**
1) `visited` 배열을 초기화한다. `visited[v]`는 정점 `v`가 방문되었는지 여부를 나타낸다. 초기에 모든 정점은 방문되지 않은 상태(NO)로 표시한다.
2) 모든 정점에 대해서 다음을 반복한다.
	1) 정점 `v`가 아직 방문되지 않았다면(`visited[v] = NO`), `aDFS(v)` 함수를 호출하여 해당 정점에서 깊이 우선 탐색을 시작한다.
**aDFS(v) 함수**
1) 현재 정점 `v`를 방문했다고 표시한다.(`visited[v] ← YES`).
2) 정점 `v`의 인접 리스트를 순회하면서, 방문하지 않은 인접 정점 `x`를 발견하면 해당 정점을 방문했다고 표시하고 `aDFS(x)` 함수를 재귀적으로 호출하여 깊이 우선 탐색을 계속 진행한다.

**7.1.3 진행과정 예시**

![[dfs 진행 과정 예시.png]]
1) 초기 노드 1의 `visited=YES` 로 설정한다.
2) 1의 인접리스트(2->3->4) 중 작은 것부터 다시 aDFS(v)를 호출한다.
3) 2의 인접리스트는 3이므로 2의 `visited=YES` 로 설정하고, 3을 탐색하러 간다.
4) 3의 인접리스트(1->2->4->5) 중 작은 것부터 다시 aDFS(v)를 호출하는데, 1과 2의 `visited=YES` 임으로 3을 `visited=YES` 로 설정하고, 4에서 탐색을 한다.
5) 4의 인접리스트는(1->3->6->7)에서 1과 3은 `visited=YES` 임으로 4를 `visited=YES` 로 설정하고, 재귀호출로 인해 6에서 다시 탐색을 한다.
6) 6의 인접리스트(4->7->8)에서 4는 `visited=YES` 임으로 6을 `visited=YES` 로 설정하고, 재귀호출로 인하여 7을 탐색한다.
7) 7의 인접리스트(4->6->8)에서 4와 6은 `visited=YES` 임으로 7을 `visited=YES` 로 설정하고, 8을 탐색한다.
8) 8도 `visited=YES` 로 설정하고, 다시 3으로 돌아와서 `visited=NO`인 5를 탐색한다.
즉, 1->2->3->4->6->7->8->5 순으로 탐색한다.

### 7.2 BFS

**7.2.1 개념**

BFS는 Breadth First Search의 약자로 한글로는 너비 우선 탐색이라고 읽는다. DFS는 알고리즘은 갈림길에서 한곳만 깊게 탐색하지만 BFS는 갈림길이 있을 경우 그 길과 연결된 노드를 전부 탐색하고 다음 노드로 이동하여 반복한다.

**7.2.2 pseudocode**
``` c
BFS(G, v) 
{ 
	for each v ∈ V –{s} 
		visited[v] ← NO; 
	
	visited[s] ← YES; ▷ s: 시작 정점 
	enqueue( Q, s); ▷ Q: 큐 
	
	while ( Q ≠ ϕ) { 
		u ← dequeue( Q); 
		for each v ∈ L(u) ▷ L(u): 정점 u의 인접 리스트 
			if (visited[v] = NO) then 
				visited[ v] ← YES; 
				enqueue( Q, v); 
	} 
} 
```
1) 그래프의 노드 수만큼 방문 여부를 확인할 배열 `visited` 생성, `visited[v]`는 정점 `v`가 방문되었는지 여부를 확인함. 즉, 처음엔 전부 `NO`
2) 시작 정점 `s`는 이미 반복했다 치고 `YES`로 바꾸고 큐 `Q`에 삽입.
3) `Q`가 비어있지 않은 동안 다음을 반복한다.
	1) 큐에서 정점 `u`를 dequeue 한다.
	2) `u`의 인접 리스트를 순회하면서, 방문하지 않은 인접 정점 `v`를 발견하면 해당 정점을 방문했다고 표시하고 큐에 enqueue 한다.

**7.2.3 진행과정 예시**

![[bfs 진행 과정 예시.png]]

1) 1을 Q 에 담음. (Q = [1])
2) 1을 `Q` 에서 제거하고 1의 인접리스트(2->3->4)를 큐에 담음.(`Q = [2, 3, 4]`)
3) 2의 인접리스트는 1->3이지만, 1과 3은 visited=`YES` 임. 따라서 탐색하지 않고 2는 `Q` 에서 삭제(`Q = [3, 4]`)
4) 3의 인접리스트는 1->2->4->5이지만 5를 제외한 나머지는 visited=`YES` 임. 따라서 3을 `Q` 에서 삭제 후 5를 큐에 담음.(`Q = [4, 5]`)
5) 4의 인접리스트는 1->3->6->7임. 1, 3은 visited=`YES` 임. 따라서 4를 `Q`에서 삭제 후 6과 7을 `Q` 에 담음.(`Q = [5, 6, 7]`) 
6) 5의 인접리스트 모두 visited=`YES` 이므로 5를 `Q` 에서 삭제.(`Q = [6, 7]`)
7) 6의 인접리스트 4->7->8 중에 8만 visited=`NO` 임으로 6을 `Q` 에서 삭제 후 8을 `Q` 에 담음.(`Q = [7, 8]`)
8) 7과 8의 인접리스트들은 모두 visited=`YES` 임으로 `Q` 에서 둘 다 삭제.
