### 4.1 Priority Queue > Heap

**4.1.1 우선순위 큐 개념**

Priority Queue 는 [[2. Stack AND Queue]] 와 비슷한 축약 자료형이다. 하지만 이들과는 다르게 순서가 있다기 보다는 각 데이터에 우선순위를 부여하는 것이다.

우선순위 큐는 완전이진트리의 형태로 구성된다. 부모의 우선순위가 자식의 우선순위보다 높은 자료구조이다. 따라서 노드의 key값이 작다면(순위의 숫자가 작을수록 높은 등급) 위로 보낸다.

![[Pasted image 20231219182444.png]]

위 이미지와 같은 형태를 갖게된다. 자식들은 부모보다 key값이 크며 자식들끼리는 따로 비교하여 작은 자식을 왼쪽으로 옮기거나 하지는 않는다.

**4.1.2 Heap 개념** 

**우선순위 큐 = 힙** 은 절대 아니다. 힙이란 우선순위 큐 자료구조를 구현하기 위해서 고안된 알고리즘이다. 

힙도 두가지 종류가 있다 :
- 최소 힙(Minimum Heap) : 키 값이 작을 수록 높은 우선 순위를 가지며 가장 작은 키가 루트에 저장된다.
- 최대 힙(Maximum Heap) : 키 값이 클 수록 더 높은 우선 순위를 가진다.

여기서는 최소 힙을 공부하였다. 우선 순위가 높은(key 값이 가장 작은) 값을 빠르게 접근하기 위해서는 그 key값을 가진 노드를 트리의 root로 옮기는 것이다. 그렇다면 O(1) 시간에 우선 순위가 가장 높은 원소에 접근할 수 있다.

**4.1.3 최솟값 삭제(우선 순위 높은 값 삭제)**

우선 순위 큐는 앞서 언급했듯이 완전이진트리의 형태를 지닌다. 따라서 먼저 root(우선 순위가 가장 높은 노드) 를 삭제하고, 가장 마지막 노드를 root로 옮기면 된다. 이때 기존 root의 자식들과의 연결도 해준다.

하지만, 이렇게만 해놓으면 key값이 가장 낮은 값이 root에 있다는 보장을 할 수 없다. 따라서 downheap 이라는 연산을 해야한다.

**4.1.4 downheap**
완전이진트리의 형태라고 하였지만, 코드 설명은 `Key` 와 `Value` 로 구성된 `Entry` 배열 로 설명하겠다.

우선 설명하기 전에 배열의 구조부터 설명하겠다. 우선순위가 가장 높은 `root` 노드는 배열 `a` 의 1번 인덱스에 저장된다. `root` 의 왼쪽 자식은 2, 오른쪽은 3에 저장된다. 2번에 저장된 노드의 왼쪽 자식은 그 다음 순번인 4, 오른쪽 자식은 그 다음 순번인 5에 채워진다. 완전이진트리의 형태이기 때문에 중간이 빌 수가 없다. 따라서 아래와 같은 형태를 갖게 된다 :

![[Pasted image 20231219182444.png]]

아래는 downheap 을 구현한 자바 코드이다 :
``` java
public class BHeap<K extends Comparable<K>, V> { // 이진(최소) 힙
    private Entry<K, V>[] a; // a[0]은 사용 안함
    private int N; // 힙의 크기
    
	private void downheap(int i) {
        while (2 * i <= N) {
            int k = 2 * i; // i의 왼쪽 자식을 k
            // 오른쪽 자식이 있으면 오른쪽 자식과 비교
            if (k < N && greater(k, k + 1)) {
                k++;
            } // 더 작은 값을 k로 설정
            if (!greater(i, k)) {
                break;
            }
            swap(i, k); // i와 k 위치를 바꿈
            i = k;
        }
    }
```
![[Pasted image 20231219184751.png]]

downheap은 루트부터 시작한다. 즉, `a[1]` 부터 시작하여 왼쪽 오른쪽 자식의 크기를 비교한다. 위 그림에서는 `a[2]=15 < a[3]=20` 의 값을 가지므로 더 작은 `a[2]` 가 승자가 되어 부모노드(root)와 위치를 바꾼다. 

그 후 `i = k` 로 업데이트한다. 즉 바꾸는 기준이 된 root 노드를 계속 따라가서 비교하겠다는 의미이다. 위 과정을 반복하여 자신이 자식들보다 값이 작은 경우에는 `break` 하여 downheap 수행을 멈춘다. 

전체 코드 -> [AVL](https://github.com/1Dohyeon/Study-DataStructure/blob/master/04_PriorityQ_with_java/D1_PriorityQ/BHeap.java)
